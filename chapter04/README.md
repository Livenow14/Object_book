# Chapter04_설계품질과 트레이드 오프

- 객체지향 설계의 핵심은 역할, 책임, 협력
- 협력 : 애플리케이션의 기능을 구현하기 위해 메세지를 주고 받는 객체들 사이의 상호작용
- 책임: 객체가 다른 객체와 협력하기 위해 수행하는 행동
- 역할: 대체 가능한 책임의 집합
- 이 세가지 중 가장 중요한 것은 **책임**
- 객체지향 설계: 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동
- 결합도와 응집도를 합리적인 수준으로 유지할 수 있는 방법은 객체의 상태가 아닌 객체의 행동에 초점을 맞추는 것

## 01. 데이터 중심의 영화 예매 시스템

- 이부분은 데이터 중심 즉 객체의 상태에 중점을 맞추었기 때문에 깊게 보지 않고, 코드만 작성하였다.

## 02. 설계 트레이드 오프

- 데이터 중심 설계와 책임 중심 설계의 장단점을 비교하기 위해 **캡슐화, 응집도, 결합도**를 사용한다.

- 캡슐화
    - 상태와 행동을 하나의 객체안에 모으는것
    - 변경될 가능성이 높은 부분을 **구현(상태)**, 상대적으로 안정된 부분을 **인터페이스(행동)**
    - 구현을 숨기고 인터페이스를 노출하는 것
    - 객체를 설계하기 위한 기본적인 아이디어는 변경의 정도에 따라 **구현**과 **인터페이스**를 분리하고 외부에서는 **인터페이스**에만 의존하도록 관계를 조절

- 응집도와 결합도
    - 응집도
        - 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타냄
        - 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도를 가진다고 함
    - 결합도
        - 의존성의 정도를 나타냄
        - 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지 나타내는 척도

    - 응집도와 결합도는 변경과 관련됨
    - 높은 응집도와 낮은 결합도는 설계를 변경하기 쉽게 만듦

    - 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도 (응집도)

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bc525092-4433-4140-a690-a3edf16d0691/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bc525092-4433-4140-a690-a3edf16d0691/Untitled.png)

    - 음영으로 칠해진 부분은 변경이 발생했을 때 수정되는 영역
    - 왼쪽은 하나의 요구사항 변경을 반영하기 위해 하나의 모듈 만 수정함

    - 한 모듈이 변경되기 위해서 다른 모듈을 변경을 요구하는 척도(결합도)

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8daab967-2412-47da-be96-a3cde3ab4544/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8daab967-2412-47da-be96-a3cde3ab4544/Untitled.png)

    - 내부구현을 변경했을 때 다른 모듈에 영항을 미치는 경우 결합도가 높다고 말함
    - 퍼블릭 인터페이스를 수정했을 때만 다른 모듈에 영향을 미치는 경우 결합도가 낮다고 표현
    - "인터페이스에 대해 프로그래밍하라"

- 캡슐화의 정도가 응집도와 결합도에 영향을 미친다.

## 03. 데이터 중심의 영화 예매 시스템의 문제점

- 기능적인 측면으로만 봤을때 이번에 짠 데이터 중심 설계와 2장의 책임 중심의 설계는 완전히 동일
- 하지만 설계 관점에서는 완전히 다름
- 데이터 중심 설계는 캡슐화를 위반하고 객체의 내부 구현을 인터페이스의 일부로 만든다.
- 책임 중심 설계는 객체의 내부 구현을 안정적인 인터페이스 뒤로 캡슐화 한다.

### 문제점 1_캡슐화 위반

- 데이터 중심으로 짠 Movie class

```jsx
public class Movie {

private Money fee;

public Money getFee() {
        return fee;
    }

public void setFee(Money fee) {
	      this.fee = fee;
    }
}
```

- 문제점
    - 메서드를 통해서만 객체 내부 상태에 접근할 수 있다.
    - 접근자, 수정자 메서드는 객체 내부의 상태에 대한 어떤 정보도 캡슐화 하지 못함
    - 따라서 위의 메소드는 캡슐화가 되지 않음
    - 또한 Money 타입의 fee라는 이름의 인스턴스 변수가 존재한다는 사실을 인터페이스에 노골적으로 드러냄

### 문제점 2_높은 결합도

- 데이터 중심으로 짠 ReservationAgency class

```jsx
public class ReservationAgency {
    public Reservation reserve(Screening screening, Customer customer,
                               int audienceCount) {
			'''
			Money fee;
        if (discountable) {
					'''
					fee = movie.getFee().minus(discountAmount).times(audienceCount);
        } else {
            fee = movie.getFee().times(audienceCount);
        }
	}
}
```

- 문제점
    - 한 명의 예매 요금을 계산하기 위해 Movie의 getFee 메서드를 호출하며 계산된 결과를 Money 타입의 fee에 저장
    - fee의 타입을 변경한다면 getFee 메서드의 반환 타입을 수정해야하고 getFee 메서드를 호출하는 ReservationAgency의 구현도 변경된 타입에 맞게 수정해야함
    - 이러한 결합도로 인해 어떤 데이터 객체를 변경하면 제어 객체를 함께 변경해야함
    - 전체 시스템을 하나의 거대한 의존성 덩어리로 만들어버림

### 문제점 3_낮은 응집도

- 서로 다른 이유로 본경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도가 낮다고 말함
- 문제점
    - 새로운 할인 정책을 추가하거나 새로운 할인 조건을 추가하기 위해 하나 이상의 클래스를 동시에 수정 해야함
- 단일 책임 원칙
    - 클래스는 단 한가지의 변경 이유만을 가저야한다.
    - 책임의 원칙에서 책임은 '변경의 이유'라는 의미로 사용된다. 이는 지금까지 살펴본 역할, 책임, 협력에서 이야기하는 책임과 다르며 변경과 관련된 더 큰 개념을 가르킨다.

## 04. 자율적인 객체를 향해

## 캡슐화를 지켜라

- 캡슐화는 설게의 제 1의 원리
- 객체는 자신이 어떤 데이터를 가지고잇는지 내부에 캡슐화하고 외부에 공개해서는 안된다.
- 스스로의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야한다.

- 객체의 상태를 접근자와 수정자로 외부 클래스에서 구현을 한다고 하면 '코드 중복'이 발생하고 '변경에 취약'하다

- 이를 해결하는것은 캡슐화를 강화 시키는 것이다. 내부에 로직을 캡슐화 하면 두가지 문제를 해결 할 수 있다.

- 캡슐화의 예

```jsx
class Rectangle {
	public void enlarge(int multiple){
		right+=multiple;
		bottom +=multiple;
	}
}
```

- Rectangle을 변경하는 주체를 외부의 객체에서 내부로 이동함.
- 자신의 크기를 스스로 증가시키도록 '책임을 이동'시켰다.

## 스스로 자신의 데이터를 책임지는 객체

- 겍체를 설계할 때 "이 객체가 어떤 데이터를 포함해야 하는가?"라는 질문의 분리
    - 이 객체가 어떤 데이터를 포함해야 하는가?
    - 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?

### 캡슐화의 진정한 의미

```jsx
캡슐화는 변경될 수 있는 어떤 것이라도 감추는 것을 의미한다. 내부 속성을 외부로부터 감추는 것은 '데이터 캡슐화'라고 불리는 캡슐화의 한 종류일 뿐이다. 
그렇기 때문에 내부 구현의 변경으로 인해 외부의 객체가 영향을 받는다면 캡슐화를 위반한 것이다. 
정리하면 캡슐화란 변하는 어떤 것이는 감추는 것이다. 그것이 무엇이든 구현과 관련된 것이라면 
```

## 06. 데이터 중심 설계의 문제점

- 데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
- 데이터 중심 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

### 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다.

- 데이터와 기능을 분리하는 것은 절차적 프로그래밍이다.
    - 이로 인해 접근자와 수정자를 과도하게 추가하게 되고 이 데이터 객체를 사용하는 절체를 분리된 별도의 객체 안에서 구현하게 됨
    - 접근자와 수정자는 public 속성과 큰 차이가 없다.

- 데이터를 먼저 결정하고 데이터를 처리하는데 필요한 오퍼레이션을 나중에 결정하는 방식은 데이터에 관한 지식이 객체의 인터페이스에 고스란히 드러나게 된다.

### 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다.

- 협력이라는 문맥 안에서 필요한 책임을 결정하고 이를 수행할 적절한 객체를 결정하는 것이 가장 중요하다.
- 올바른 객체지향 설계의 무게 중심은 객체 내부가 아닌 객체 외부에 맞춰져야 한다 .
- 중요한 것은 객체가 다른 객체와 협력하는 방법이다.
- 데이터 중심 설계에서 초점은 외부가 아닌 내부로 향하여서 실행 문맥에 대한 고민 없이 객체가 관리할 데이터의 세부 정보를 먼저 결정한다.
    - 그렇기에 이미 구현된 객체의 인터페이스를 억지로 끼워맞출 수 밖에 없다.