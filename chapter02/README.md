# Chapter 02_객체지향 프로그래밍

### 01. 영화 예매 시스템

- 요구사항 살펴보기

```jsx
온라인 영화 예매 시스템, 사용자는 영화 예매 시스템을 이용해 쉽고 빠르게 보고싶은 영화를 예매 할 수 있다.
'영화'는 영화에 대한 기본 정보를 표현한다. 제목, 상영시간, 가격 정보와 같이 영화가 가지고 있는 기본적인 정보를 가리킬 때믄 '영화'라는 단어를 사용한다.
'상영'은 실제로 관객들이 영화를 관람하는 사건을 표현한다. 상영 일자, 시간, 순번 등을 가리키기 위해 '상영'이라는 용어를 사용한다. 

특정한 조건을 만족하는 예매자는 요금을 할인받을 수 있다. 할인액을 결정하는 두 가지 규칙이 존재하는데, 하나는 "할인 조건(discount condition)"이라고 부르고, 다른 하나는 "할인 정책(discount policy)"라고 부른다. 

'할인 조건'은 가격의 할인 여부를 결정하며 '순서 조건'과 '기간 조건'의 두 종류로 나눌 수 있다. 
'순서조건(sequence condition)'은 상영 순번을 이용해 할인 여부를 결정하는 규칙이다. 
'기간 조건(period condition)'은 영화 상영 시작 시간을 이용해 할인 여부를 결정한다. 기간 조건은 요일, 시작 시간, 종료 시간의 세 부분으로 구성되며 영화 시작 시간이 해당 기간 안에 포함될 경우 요금을 할인한다. 

'할인 정책'은 할인 요금을 결정한다. 할인 정책에는 '금액 할인 정책(amount discount policy)'과 '비율 할인 정책(percent discount policy)'이 있다. 
'금액 할인 정책'은 예매 요금에서 일정 금액을 할인해주는 방식이며
'비율 할인 정책'은 정가에서 일정 비율의 요금을 할인해 주는 방식이다. 

영화별로 하나의 할인 정책만 할당할 수 있다. 물론 할인 정책을 지정하지 않는 것도 가능하다. 이와 달리 할인 조건은 다수의 할인 조건을 함꼐 지정할 수 있으며, 순서 조건과 기간 조건을 섞는 것도 가능하다. 

```

### 02. 협력, 객체, 클래스

진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다. 이를위해서는 프로그래밍하는 동안 다음의 두 가지에 집중해야 한다. 

첫째, 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라. 

둘째. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야한다. 

### 자율적인 객체

- 객채는 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재이다.
- 객체는 스스로 판단하고 행동하는 자율적인 존재이다.

객체지향은 객체라는 단위 안에 데이터와 기능을 한 덩어리로 묶음으로써 문제 영역의 아이디어를 적절하게 표현할 수 있게 했다. 이처럼 데이터와 기능을 객체 내부로 함께 묶는 것을 캡슐화라고 한다. 

이떄 default, public, protected, private과 같은 접근 수정자(access modifier)를 제공한다. 이는 객체를 자율적인 존재로 만들기 위해서다. 

캡슐화와 접근 제어는 객체를 두 부분으로 나눈다. 하나는 외부에서 접근 가능한 부분으로 이를 '퍼블릭 인터페이스(public interface)'라고 부른다.  다른 하나는 접근 불가능하고 오직 내부에서만 접근 가능한 부분으로 이를 '구현(implementation)'이라고 부른다. 

'인터페이스와 구현의 분리(separation of interface and implementation)' 원칙은 훌륭한 객체 지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙이다. 

일반적으로 객체의 상태는 숨기고 행동만 외부에 공개해야 한다. 클래스의 속성은 private으로 선언해서 감추고 외부에 제공해야 하는 일부 메서드만 public으로 선언해야 한다. 어떤 메서드들이 서브클래스나 내부에서만 접근 가능해야 한다면 가시성을 protected나 private으로 지정해야 한다. 이때 퍼블릭 인터페이스에는 public으로 지정된 메서드만 포함된다. 그 밖의 private 메서드나 protected 메서드, 속성은 구현에 포함된다.

### 프로그래머의 자유

객체의 외부와 내부를 구분하면 클라이언트 프로그래머가 알아야 할 지식의 양이 줄어들고 클래스 작성자가 자유롭게 구현을 변경할 수 있는 폭이 넓어진다. 따라서 클래스를 개발할 때마다 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야 한다. 

### 협력에 관한 짧은 이야기

객체가 다른 객체와 상호작용할 수 잇는 유일한 방법은 메세지를 전송하는 것 뿐이다. 다른 객체에게 요청이 도착할 때 해당 객체가 메세지를 수신 했다고 이야기한다. 메세지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메세지를 처리할 방법을 결정한다. 이처럼 수신된 메세지를 처리하기 위한 자신만의 방법을 메서드라고 부른다. 

메세지와 메서드를 구분하는 것은 매우 중요하다. 매세지와 메서드의 구분에서부터 다형성(polymorphism)의 개념이 출발한다.   

지금까지는 Screening이 Movie의 calculateMovieFee '메서드를 호출한다'고 말했지만 실은 Screening이 Movie에게 calculateMovieFee '메세지를 전송'한다는 표현이 적절하다. 

메세지를 수신한 Movie는 스스로 적절한 메서드를 선택한다.  결국 메세지를 처리하는 방법을 결정하는 것은 Movie스스로의 문제인 것이다. 이것이 객체가 메세지를 처리하는 방법을 자율적으로 결정할 수 있다고 말했던 이유다. 

```jsx
오버라이딩과 오버로딩  
많은 사람들이 오버라이딩(overriding)과 오버로딩(overloading)의 개념을 혼동한다. 오버라이딩은 부모 클래스에 정의된 같은 이름, 같은 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의하는 경우를 가리킨다. 자식 클래스의 메서드는 오버라이딩한 부모 클래스의 메서드를 가리기 때문에 외부에서는 부모 클래스의 메서드가 보이지 않는다.  
오버로딩은 메서드의 이름은 같지만 제공되는 파라미터의 목록이 다르다. 오버로딩한 메서드는 원래의 메서드를 가리지 않기 때문에 이 메서드들은 사이 좋게 공존한다. 

오버로딩의 예
public Money (Money amount) {
}
public Money(int a, int b){
}

```

## 04 상속과 다형성

어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 객체의 메서드를 호출할 경우 두 클래스 사이에 의존성이 존재한다고 말한다.   

코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다. 다시 말해 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다. 그리고 유연하고, 쉽게 재사용할 수 있으며, 확장 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다는 것이다. 

한가지 간과해서는 안 되는 사실은 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워 진다는 것이다. 코드를 이해하기 위해서는 코드뿐만 아니라 객체를 생성하고 연결하는 부분을 찾아야 하기 때문이다. 반면 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드는 더 유연해지고 확장 가능해진다 .이와 같은 의존성의 양면성은 설계가 트레이드오프의 산물이라는 사실을 잘 보여준다. 

### 차이에 의한 프로그래밍

클래스의 코드를 전혀 수정하지 않고도 재사용하는 것을 가능하게 해주는 방법이 상속이다.

AmountDiscountPolicy와 percentDiscountPolicy의 경우 DiscountPolicy에서 정의한 추상 메서드인 getDiscountAmount 메서드를 오버라이딩해서 DiscountPolicy의 행동을 수정한다는 것을 알 수 있다. 

이를  "차이에 의한 프로그래밍(programming by difference)"이고 부른다.

### 상속과 인터페이스

상속이 가치 있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 대문이다. 

인터페이스는 객체가 이해할 수 있는 메세지의 목록을 정의한다는 것을 기억하자. 상속을 통해 자식 클래스는 자신의 언터페이스에 부모 클래스의 인터페이스를 포함하게 된다. 결과적으로 자식 클래스는 무보 클래스가 수신할 수 있는 모든 메세지를 수신할 수 있기 대문에 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있다.

```jsx
public Money calculateMovieFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
```

Moive가 DiscountPolicy의 인터페이스에 정의된 calculateDiscountAmount 메세지를 전송하고 있다. DiscountPolicy를 상속받는 두개의 인터페이스에서도 이 오퍼레이션이 포함되어 있는 사실에 주목하자. Movie입장에서는 자신과 협력하는 객체가 어떤 클래스의 언스턴스인지가 중요한 것이 아니라 calculateDiscounAmount라는 메세지를 수신할 수 있다는 사실이 중요하다. 

이처럼 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅(upcasting)이라고 부른다. 아래에 위치한 자식 클래스가 위에 위치한 부모 클래스로 자동적으로 타입 캐스팅되는 것처럼 부이기 때문에 업캐스팅이라는 용어를 사용한다. 

묵시적 명시적

### 다형성

Movie는 동일한 메세지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메세지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다 이를 "다형성"이라고 부른다. 

다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다. 

다형적인 협력에 참여하는 객체들은 모두 같은 메세지를 이해할 수 있어야 한다. 다시말해 인터페이스가 동일해야한다. 

다형성을 구현하는 방법은 매우 다양하지만 메세지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다는 공통점이 있다. 다시 말해 메세지와 메서드를 실행 시점에 바인딩 한다는 것이다. 이를 지연 바인딩(lazy binding) 또는 동적 바인딩(dynamic binding)이라고 부른다. 그에 반해 전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결졍하는 것을 초기 바인딩(early binding) 또는 정적 바인딩(static binding)이라고 부른다. 객체지향이 컴파일 시점의 의존성과 실행 시점의 의존성을 분리하고, 하나의 메세지를 선택적으로 서로 다른 메서드에 연결할 수 있는 이유가 바로 지연 바인딩이라는 메커니즘을 사용하기 때문이다. 

## 05 추상화와 유연성

### 상속

상속의 가장큰 문제점은 캡슐화를 위반한다는 것이고, 다른 하나는 설계를 유연하지 못하게 만든다는 것이다. 

### 합성

Movie는 요금을 계산하기 위해 DiscountPolicy의 코드를 재사용한다. 이 방법이 상속과 다른 점은 상속이 부모 클래스의 코드와 자식 클래스의 코드를 컴파일 시점의 하나의 단위로 강하게 결합하는데 비해 Moive가 DiscountPolicy의 인터페이스를 통해 약하게 결합된다는 것이다. 실제로 Movie는 DiscountPolicy가 외부에 calculateDiscountAmoun 메서드를 제공한다는 사실만 알고 내부 구현에 대해서는 전혀 알지 못한다. 이처럼 인터페이스에 정의된 메세지를 통해서만 코드를 재사용하는 방법을 합성이라고 부른다. 

합성은 상속이 가지는 두 가지 문제점을 모두 해결한다. 인터페이스에 정의된 메세지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화 할 수 있다. 또한 의존하는 인스턴스를 교체한느 것이 비교적 쉽기 때문에 설계를 유연하게 만든다. 상속은 클래스를 통해 강하게 결합되는 데 비해 합성은 메세지를 통해 느슨하게 결합된다. 따라서 코드 재사용을 위해서는 상속보다는 합성을 선호하는 것이 더 좋은 방법이다. 

대부분의 설계에서는 상속과 합성을 함꼐 사용해야한다.

## 결론

객체지향 패러다임의 중심에는 객체가 위치한다. 그러나 각 객체를 따로 떼어 놓고 이야기 하는 것은 무의미하다. 객체지향에서 가장 중요한 것은 애플리케이션의 기능을 구현하기 위해 협력에 참여하는 객체들 사이의 상호작용이다.   

객체지향 설계의 핵심은 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에 역할을 수행할 수 있는 적절한 객체에게 책임을 할당하는 것이다.