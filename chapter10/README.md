# Chapter10_상속과 코드 재사용

- 객체지향에서 클래스를 재사용하는 전통적인 방법은 새로운 클래스를 추가하는 것
- **상속**과 **합성**의 장단점

## 01 상속과 중복 코드

- 중복코드를 제거해야 할 이유

### DRY 원칙(Don't Repeat Yourself)

- "모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을 만한 표현 양식을 가져야 한다. "
- 중복코드는 변경을 방해
    - 변경은 중복 여부를 판단하는 기준
        - 요구사항이 변경됐을 때 두 코드를 함께 수정해야 한다면 중복
    - 중복을 결정하는 기준은 코드가 변경에 반응하는 방식

### 중복과 변경

중복코드 살펴보기 

- 한 달에 한 번씩 가입자별로 전화 요금을 계산하는 간단한 어플리케이션
- 이하 코드상으로 확인
- (상속을 위한 경고1)자식 클래스의 메서드 안에서 super참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.

## 02 취약한 기반 클래스 문제

- Step5까지 살펴본 것처럼 상속은 자식 클래스와 부모 클래스의 결합도를 높임
    - 이를 **취약한 기반 클래스 문제**라고 부름
- 객체지향의 기반은 캡슐화를 통한 변경의 통제

### 불필요한 인터페이스 상속 문제

- (상속을 위한 경고2)상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.

### 메서드 오버라이딩의 오작용 문제

- InstrumentedHashSet은 HashSet의 내부에 저장된 요소의 수를 셀 수 있는 기능을 추가한 클래스, HashSet의 자식 클래스로 구현됨
- 이하 코드상으로 확인
- (상속을 위한 경고3)자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.

### 부모 클래스와 자식 클래스의 동시 수정 문제

- playlist 코드 확인 ,
    - 자식 클래스가 부모 클래스의 메서드를 오버라이딩하거나 불필요한 인터페이스를 상속받지 않았음에도 부모 클래스를 수정할 때 자식 클래스를 함께 수정해야 할 수 있따는 사실을 보여줌

(상속을 위한 경고4) 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다. 

## 03 Phone 다시 살펴보기

### 추상화에 의존하자

- step6 코드 확인
    - 부모 클래스와 지삭 클래스 모두 추상화에 의존하도록 수정함

### 차이를 메서드로 추출하라

- 변하는 것으로부터 변하지 않는 것을 분리
- 변하는 부분을 찾고 이를 캡슐화하라

### 중복 코드를 부모 클래스로 올려라

- 공통 부분을 부모 클래스로 이동시킴

### 추상화가 핵심이다

- 추상화에 의존하면 얻을 수 잇는 장점
    - 공통 코드를 이동시킨 후에 각 클래스는 서로 다른 변경의 이유를 가짐
    - calculateCallFee 메서드의 시그니처가 변경되지 않는한 부모의 클래스의 내부 구현이 변경되더라도 자식 클래스는 영향을 받지 않은음
    - 의존성 역전 원칙 준수
    - 새로운 요금제 추가 용이

## 04 차이에 의한 프로그래밍

- 현재처럼 기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법
- 중복 코드 제거 == 코드 재사용

![https://user-images.githubusercontent.com/48986787/90311740-63e05e80-df39-11ea-89d5-48a074d3cb76.png](https://user-images.githubusercontent.com/48986787/90311740-63e05e80-df39-11ea-89d5-48a074d3cb76.png)

- 상속이 위의 문제를 해결해 주는듯 하지만 코드 재사용에 있어서는 좋지 않음
- 이보다 더 좋은 방법이 합성이다.